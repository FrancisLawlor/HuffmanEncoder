import java.util.*;

/**
 * This class is to be used as a utility for encoding random variables as Huffman Code.
 *
 * @author Francis Lawlor
 */
class HuffmanEncoder {

	/**
	 * Generates a list of Code objects containing the generated Huffman Codes as strings.
	 *
	 * The random variable is converted to a collection of nodes. Dummy nodes will be added if required.
	 *
	 * A tree is constructed for the purposes of generating the codes. Once complete a depth first search
	 * is carried out on the tree to find the leaves. Once a leaf is found, the code is generated by moving
	 * back up the tree towards the parent.
	 *
	 * @param pmf the pmf of the random variable
	 * @param D the size of the alphabet used to encode the random variable
	 */
	public static LinkedList<Code> generateHuffmanCode(LinkedList<Double> pmf, int D) {
		private LinkedList<Code> codes = new LinkedList<Code>();
		private LinkedList<Node> nodes = new LinkedList<Node>();
		private LinkedList<String> codeValueStrings = new LinkedList<String>();
		private LinkedList<String> huffmanCodeStrings = new LinkedList<String>();

		for (int i = 0; i < pmf.size(); i++) {
			nodes.add(new Node(pmf.get(i)));
		}

		addDummyNodes(nodes, D);
		sortNodes(nodes);

		storeCodeValueStrings(nodes, codeValueStrings);

		while (nodes.size() != 1) {
			sortNodes(nodes);

			// Create new node and add D smallest elements as children.
			Node newParent = new Node(0.0);

			for (int i = 0; i < D; i++) {
				newParent.addChild(nodes.get(nodes.size() - 1));
				newParent.setNodeVal(newParent.getNodeVal() + nodes.get(nodes.size() - 1).getNodeVal());
				nodes.remove(nodes.size() - 1);
			}

			newParent.sortChildren();

			// Add indices to children for use in obtaining codes later.
			for (int i = 0; i < newParent.getChildren().size(); i++) {
				newParent.getChildren().get(i).setIndex(i);
			}

			nodes.add(newParent);
		}

		huffmanCodeStrings = generateHuffmanCodeStrings(nodes.get(0));

		for (int i = 0; i < codeValueStrings.size(); i++) {
			codes.add(new Code(codeValueStrings.get(codeValueStrings.size() - 1 - i), huffmanCodeStrings.get(i)));
		}

		return codes;
	}

	/**
	 * Sorts the nodes in ascending order.
	 *
	 * @param nodes a LinkedList containing the nodes to be sorted.
	 */
	private static void sortNodes(LinkedList<Node> nodes) {
		for (int i = 0; i < nodes.size(); i++) {
			for (int j = i + 1; j < nodes.size(); j++) {
				if (nodes.get(i).getNodeVal() < nodes.get(j).getNodeVal()) {
					double temp = nodes.get(j).getNodeVal();
					nodes.get(j).setNodeVal(nodes.get(i).getNodeVal());
					nodes.get(i).setNodeVal(temp);
				}
			}
		}
	}

	/**
	 * Generates a string for each Huffman Code.
	 *
	 * Carries out Depth First Search on the tree and obtains code by moving up from
	 * leaf nodes.
	 *
	 * @param root parent node of the tree to be traversed.
	 */
	private static LinkedList<String> generateHuffmanCodeStrings(Node root) {
		LinkedList<String> codeStrings = new LinkedList<String>();
		LinkedList<Node> nodesToVisit = new LinkedList<Node>();

		nodesToVisit.add(root);

		while (!nodesToVisit.isEmpty()) {
			Node currentNode = nodesToVisit.get(0);
			nodesToVisit.remove(0);

			for (Node n: currentNode.getChildren()) {
				nodesToVisit.add(n);
			}

			Node expandedNode = currentNode;

			// Trace edge nodes upwards to root to obtain the code.
			if (expandedNode.getChildren().size() == 0) {
				StringBuilder codeBuilder = new StringBuilder();

				while (!expandedNode.equals(root)) {
					codeBuilder.insert(0, expandedNode.getIndex());
					expandedNode = expandedNode.getParent();
				}

				codeStrings.add(codeBuilder.toString());
			}
		}

		return codeStrings;
	}

	/**
	 * Adds dummy nodes to initial list if required.
	 *
	 * @param currentNodes initial list of nodes
	 * @param D the size of the alphabet used to encode the random variable
	 */
	private static void addDummyNodes(LinkedList<Node> currentNodes, int D) {
		while (((currentNodes.size() - 1) / ((float) D - 1)) % 1 != 0) {
			currentNodes.add(new Node(0.0));
		}
	}

	/**
	 * Stores values of nodes for later use in populating code list.
	 *
	 * @param nodes list of initial nodes and dummy nodes
	 * @param codeValueStrings list of Strings corresponding to values of nodes.
	 */
	private static void storeCodeValueStrings(LinkedList<Node> nodes, LinkedList<String> codeValueStrings) {
		for (Node node: nodes) {
			codeValueStrings.add(Double.toString(node.getNodeVal()));
		}
	}
}
